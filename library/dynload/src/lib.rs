//! Safe dynamic loading of Rust libraries with ABI verification.
//!
//! This crate provides utilities for loading Rust dynamic libraries that were
//! compiled with the `#[dynexport]` attribute, enabling runtime ABI verification
//! before calling exported functions.
//!
//! # Example
//!
//! ```ignore
//! use dynload::{DynLibrary, TypeHash};
//!
//! // Load a library
//! let lib = DynLibrary::open("libmylib.dylib")?;
//!
//! // Load a function with type verification
//! let add: fn(i32, i32) -> i32 = unsafe {
//!     lib.get_verified("add", TypeHash::new::<fn(i32, i32) -> i32>())?
//! };
//!
//! // Call it
//! println!("Result: {}", add(3, 4));
//! ```

use std::collections::hash_map::DefaultHasher;
use std::ffi::OsStr;
use std::hash::{Hash, Hasher};
use std::marker::PhantomData;

pub use libloading;
use libloading::{Library, Symbol};

/// Errors that can occur during dynamic loading.
#[derive(Debug, thiserror::Error)]
pub enum DynloadError {
    /// Failed to open the library file.
    #[error("failed to open library: {0}")]
    OpenFailed(#[from] libloading::Error),

    /// The requested symbol was not found.
    #[error("symbol '{0}' not found")]
    SymbolNotFound(String),

    /// No metadata found for the symbol (not compiled with #[dynexport]).
    #[error("no dynexport metadata for symbol '{0}' - was it compiled with #[dynexport]?")]
    NoMetadata(String),

    /// Type hash mismatch - ABI incompatibility detected.
    #[error("type mismatch for '{symbol}': expected hash 0x{expected:016x}, got 0x{actual:016x}")]
    TypeMismatch {
        symbol: String,
        expected: u64,
        actual: u64,
    },

    /// Compiler version mismatch.
    #[error("compiler version mismatch for '{symbol}': expected 0x{expected:08x}, got 0x{actual:08x}")]
    CompilerMismatch {
        symbol: String,
        expected: u32,
        actual: u32,
    },
}

/// Result type for dynload operations.
pub type Result<T> = std::result::Result<T, DynloadError>;

/// Metadata structure for dynexport symbols.
/// Must match the layout generated by the compiler.
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct DynexportMeta {
    /// Hash of the type signature for ABI verification.
    pub type_hash: u64,
    /// Hash of the compiler version.
    pub compiler_hash: u32,
    /// Reserved flags for future use.
    pub flags: u32,
}

/// A type hash for verifying function signatures.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TypeHash(pub u64);

impl TypeHash {
    /// Create a type hash from any type.
    /// Note: This uses std::any::type_name which may not be stable across compilations.
    /// For reliable verification, use the hash from the library's metadata.
    pub fn of<T: ?Sized>() -> Self {
        let type_name = std::any::type_name::<T>();
        let mut hasher = DefaultHasher::new();
        type_name.hash(&mut hasher);
        TypeHash(hasher.finish())
    }

    /// Create a type hash from a raw value.
    pub fn from_raw(hash: u64) -> Self {
        TypeHash(hash)
    }
}

/// Options for library loading.
#[derive(Debug, Clone, Default)]
pub struct LoadOptions {
    /// If true, skip type hash verification (unsafe!).
    pub skip_type_check: bool,
    /// If true, skip compiler version check.
    pub skip_compiler_check: bool,
    /// Expected compiler hash (if known).
    pub expected_compiler_hash: Option<u32>,
}

/// A dynamically loaded Rust library with ABI verification support.
pub struct DynLibrary {
    lib: Library,
}

impl DynLibrary {
    /// Open a dynamic library from the given path.
    ///
    /// # Safety
    ///
    /// This function loads executable code. The library must be trusted.
    pub unsafe fn open<P: AsRef<OsStr>>(path: P) -> Result<Self> {
        let lib = Library::new(path)?;
        Ok(Self { lib })
    }

    /// Get the metadata for a dynexport symbol, if available.
    pub fn get_metadata(&self, symbol_name: &str) -> Result<DynexportMeta> {
        let meta_name = format!("dynexport_meta_{}\0", symbol_name);
        unsafe {
            let meta_sym: Symbol<*const DynexportMeta> =
                self.lib.get(meta_name.as_bytes()).map_err(|_| {
                    DynloadError::NoMetadata(symbol_name.to_string())
                })?;
            Ok(**meta_sym)
        }
    }

    /// Check if a symbol has dynexport metadata.
    pub fn has_metadata(&self, symbol_name: &str) -> bool {
        self.get_metadata(symbol_name).is_ok()
    }

    /// Get a raw symbol without any verification.
    ///
    /// # Safety
    ///
    /// The caller must ensure the symbol type matches the actual type in the library.
    pub unsafe fn get_raw<T>(&self, symbol_name: &str) -> Result<Symbol<'_, T>> {
        let name_with_null = format!("{}\0", symbol_name);
        self.lib
            .get(name_with_null.as_bytes())
            .map_err(|_| DynloadError::SymbolNotFound(symbol_name.to_string()))
    }

    /// Get a function with type hash verification.
    ///
    /// Verifies that the type hash in the library's metadata matches the expected hash.
    ///
    /// # Safety
    ///
    /// The caller must ensure the type `T` actually matches the function signature.
    /// The type hash check provides additional safety but is not foolproof.
    pub unsafe fn get_verified<T>(
        &self,
        symbol_name: &str,
        expected_hash: TypeHash,
    ) -> Result<Symbol<'_, T>> {
        let meta = self.get_metadata(symbol_name)?;

        if meta.type_hash != expected_hash.0 {
            return Err(DynloadError::TypeMismatch {
                symbol: symbol_name.to_string(),
                expected: expected_hash.0,
                actual: meta.type_hash,
            });
        }

        self.get_raw(symbol_name)
    }

    /// Get a function, verifying only that metadata exists (no type check).
    ///
    /// This is useful when you trust the library but want to ensure it was
    /// compiled with #[dynexport].
    ///
    /// # Safety
    ///
    /// The caller must ensure the type `T` matches the actual function signature.
    pub unsafe fn get_with_metadata<T>(&self, symbol_name: &str) -> Result<Symbol<'_, T>> {
        let _meta = self.get_metadata(symbol_name)?;
        self.get_raw(symbol_name)
    }

    /// Get the compiler hash from a symbol's metadata.
    pub fn get_compiler_hash(&self, symbol_name: &str) -> Result<u32> {
        Ok(self.get_metadata(symbol_name)?.compiler_hash)
    }

    /// Check if two symbols were compiled with the same compiler version.
    pub fn same_compiler(&self, symbol1: &str, symbol2: &str) -> Result<bool> {
        let hash1 = self.get_compiler_hash(symbol1)?;
        let hash2 = self.get_compiler_hash(symbol2)?;
        Ok(hash1 == hash2)
    }

    /// Get the underlying libloading Library for advanced use.
    pub fn inner(&self) -> &Library {
        &self.lib
    }
}

/// A typed function handle with verified ABI.
pub struct DynFn<F> {
    ptr: *const (),
    _marker: PhantomData<F>,
}

impl<F> DynFn<F> {
    /// Create a new DynFn from a raw pointer.
    ///
    /// # Safety
    ///
    /// The pointer must point to a valid function with the signature `F`.
    pub unsafe fn from_ptr(ptr: *const ()) -> Self {
        Self {
            ptr,
            _marker: PhantomData,
        }
    }
}

// Implement calling for common function signatures
macro_rules! impl_dyn_fn_call {
    ($($arg:ident),*) => {
        impl<R, $($arg),*> DynFn<fn($($arg),*) -> R> {
            /// Call the function.
            #[allow(non_snake_case)]
            pub fn call(&self, $($arg: $arg),*) -> R {
                let f: fn($($arg),*) -> R = unsafe { std::mem::transmute(self.ptr) };
                f($($arg),*)
            }
        }
    };
}

impl_dyn_fn_call!();
impl_dyn_fn_call!(A);
impl_dyn_fn_call!(A, B);
impl_dyn_fn_call!(A, B, C);
impl_dyn_fn_call!(A, B, C, D);
impl_dyn_fn_call!(A, B, C, D, E);
impl_dyn_fn_call!(A, B, C, D, E, F);

/// Helper to load multiple functions from a library with verification.
#[macro_export]
macro_rules! load_functions {
    ($lib:expr, { $($name:ident : $ty:ty = $hash:expr),* $(,)? }) => {
        {
            $(
                let $name: $crate::libloading::Symbol<$ty> = unsafe {
                    $lib.get_verified(stringify!($name), $crate::TypeHash::from_raw($hash))?
                };
            )*
            Ok(($($name),*))
        }
    };
}

/// Information about a loaded library's exports.
#[derive(Debug)]
pub struct LibraryInfo {
    /// Path to the library.
    pub path: String,
    /// List of discovered dynexport symbols with their metadata.
    pub exports: Vec<(String, DynexportMeta)>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_hash() {
        let hash1 = TypeHash::of::<fn(i32, i32) -> i32>();
        let hash2 = TypeHash::of::<fn(i32, i32) -> i32>();
        let hash3 = TypeHash::of::<fn(i32) -> i32>();

        assert_eq!(hash1, hash2);
        assert_ne!(hash1, hash3);
    }

    #[test]
    fn test_dynexport_meta_size() {
        // Verify the struct size matches what the compiler generates
        assert_eq!(std::mem::size_of::<DynexportMeta>(), 16);
        assert_eq!(std::mem::align_of::<DynexportMeta>(), 8);
    }
}
