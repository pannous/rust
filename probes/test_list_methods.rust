#!/usr/bin/env rust
// Test working list methods
// DON'T REMOVE TESTS even if they fail

fn test_list_indexing() {
    let my_list =[1, 2, 3]
    eq!( my_list[1] , 2 )
}

fn test_list_first_last() {
    let my_list =[1, 2, 3]
    eq!( my_list.first() , Some(&1) )
    eq!( my_list.last() , Some(&3) )
}

fn test_list_len_methods() {
    let my_list =[1, 2, 3]
    eq!( my_list.len() , 3 )
    eq!( my_list.size() , 3 )
    eq!( my_list.length() , 3 )
}

fn test_list_contains() {
    let my_list =[1, 2, 3]
    eq!( my_list.contains(&2) , true )
    eq!( my_list.contains(&5) , false )
}

fn test_list_in_operator() {
    let my_list =[1, 2, 3]
    eq!( 2 in my_list , true )
    eq!( 5 in my_list , false )
}

fn test_list_sort() {
    let mut sorted =[3, 1, 2]
    sorted.sort()
    eq!( sorted , [1,2,3] )
}

fn test_list_to_vec() {
    let my_list =[1, 2, 3]
    eq!( my_list.to_vec() , vec![1,2,3] )
}

fn test_string_list_join() {
    let stringList =["3", "2", "1"]
    eq!( stringList.join("-") , "3-2-1" )
    eq!( stringList.join("") , "321" )
}

fn test_list_iter() {
    let my_list =[1, 2, 3]
    let mut sum =0
    for x in my_list.iter() { sum += x }
    eq!( sum , 6 )
}

fn test_list_get() {
    let my_list =[1, 2, 3]
    eq!( my_list.get(1) , Some(&2) )
    eq!( my_list.get(99) , None )
}

fn test_list_is_empty() {
    let my_list =[1, 2, 3]
    eq!( my_list.is_empty() , false )
    let empty: [i32; 0] = []
    eq!( empty.is_empty() , true )
}

fn test_vec_reverse() {
    let mut rev =vec![1, 2, 3]
    rev.reverse()
    eq!( rev , vec![3, 2, 1] )
}

fn test_list_indexof() {
    let my_list =[1, 2, 3]
    eq!( my_list.indexOf(&2) , 1 )
    eq!( my_list.indexOf(&5) , -1 )
}

fn test_list_slice() {
    let my_list =[1, 2, 3]
    eq!( my_list.slice(1,3) , vec![2,3] )
    eq!( my_list.slice(0,2) , vec![1,2] )
}

fn test_list_copy() {
    let my_list =[1, 2, 3]
    eq!( my_list.copy() , vec![1,2,3] )
}

fn test_list_append() {
    let my_list =[1, 2, 3]
    eq!( my_list.append(4) , vec![1,2,3,4] )
}

fn test_list_prepend() {
    let my_list =[1, 2, 3]
    eq!( my_list.prepend(0) , vec![0,1,2,3] )
}

fn test_list_insert() {
    let my_list =[1, 2, 3]
    eq!( my_list.insert(1, 99) , vec![1,99,2,3] )
}

fn test_list_reversed() {
    let my_list =[1, 2, 3]
    eq!( my_list.reversed() , vec![3,2,1] )
}

fn test_list_sorted() {
    eq!( [3,1,2].sorted() , vec![1,2,3] )
}

fn test_list_sorted_desc() {
    eq!( [1,2,3].sortDesc() , vec![3,2,1] )
}

fn test_len_function() {
    let emptyVec: Vec<i32> = @[]
    eq!( len(emptyVec) , 0 )
    eq!( len(@[1]) , 1 )
    eq!( len(@[1,2,3]) , 3 )
}

fn test_empty_collection_edge_cases() {
    let empty_arr: [i32; 0] = []
    eq!( empty_arr.first() , None )
    eq!( empty_arr.last() , None )
    eq!( empty_arr.indexOf(&1) , -1 )
    eq!( empty_arr.contains(&1) , false )
    eq!( empty_arr.reversed() , vec![] as Vec<i32> )
}

fn test_single_element_collection() {
    let single =[42]
    eq!( single.first() , Some(&42) )
    eq!( single.last() , Some(&42) )
    eq!( single.indexOf(&42) , 0 )
    eq!( single.len() , 1 )
    eq!( single.reversed() , vec![42] )
    eq!( single.sorted() , vec![42] )
    eq!( single.sortDesc() , vec![42] )
}

fn test_boundary_slice_operations() {
    let three =[1, 2, 3]
    eq!( three.slice(0, 0) , vec![] as Vec<i32> )
    eq!( three.slice(0, 3) , vec![1, 2, 3] )
    eq!( three.slice(2, 3) , vec![3] )
    eq!( three.slice(3, 3) , vec![] as Vec<i32> )
}

fn test_indexof_with_duplicates() {
    let dups =[1, 2, 2, 3, 2]
    eq!( dups.indexOf(&2) , 1 )
    eq!( dups.indexOf(&3) , 3 )
}

fn test_insert_at_boundaries() {
    let three =[1, 2, 3]
    eq!( three.insert(0, 99) , vec![99, 1, 2, 3] )
    eq!( three.insert(3, 99) , vec![1, 2, 3, 99] )
}

fn test_append_prepend_single_element() {
    let single =[42]
    eq!( single.append(99) , vec![42, 99] )
    eq!( single.prepend(99) , vec![99, 42] )
}

fn test_join_on_empty_and_single_element() {
    let empty_str: [&str; 0] = []
    eq!( empty_str.join(",") , "" )
    eq!( ["solo"].join(",") , "solo" )
}

fn test_get_with_boundary_indices() {
    let my_list =[1, 2, 3]
    eq!( my_list.get(0) , Some(&1) )
    eq!( my_list.get(2) , Some(&3) )
    eq!( my_list.get(3) , None )
}

fn test_contains_with_boundary_elements() {
    let my_list =[1, 2, 3]
    eq!( my_list.contains(&1) , true )
    eq!( my_list.contains(&3) , true )
}

fn test_in_operator_with_boundaries() {
    let my_list =[1, 2, 3]
    eq!( 1 in my_list , true )
    eq!( 3 in my_list , true )
    eq!( 0 in my_list , false )
    eq!( 4 in my_list , false )
}

fn test_sorted_desc_on_descending() {
    let desc =[5, 4, 3, 2, 1]
    eq!( desc.sortDesc() , vec![5, 4, 3, 2, 1] )
}

fn test_sorted_on_ascending() {
    let asc =[1, 2, 3, 4, 5]
    eq!( asc.sorted() , vec![1, 2, 3, 4, 5] )
}

fn main() {
    test_list_indexing();
    test_list_first_last();
    test_list_len_methods();
    test_list_contains();
    test_list_in_operator();
    test_list_sort();
    test_list_to_vec();
    test_string_list_join();
    test_list_iter();
    test_list_get();
    test_list_is_empty();
    test_vec_reverse();
    test_list_indexof();
    test_list_slice();
    test_list_copy();
    test_list_append();
    test_list_prepend();
    test_list_insert();
    test_list_reversed();
    test_list_sorted();
    test_list_sorted_desc();
    test_len_function();
    test_empty_collection_edge_cases();
    test_single_element_collection();
    test_boundary_slice_operations();
    test_indexof_with_duplicates();
    test_insert_at_boundaries();
    test_append_prepend_single_element();
    test_join_on_empty_and_single_element();
    test_get_with_boundary_indices();
    test_contains_with_boundary_elements();
    test_in_operator_with_boundaries();
    test_sorted_desc_on_descending();
    test_sorted_on_ascending();
}
