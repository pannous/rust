#!/usr/bin/env rust

#[test]
fn test_null_coalesce_with_some() {
	let some_val: Option<i32> = Some(42);
	let result = some_val.unwrap_or(0);
	assert_eq!(result, 42);
}

#[test]
fn test_null_coalesce_with_none() {
	let none_val: Option<i32> = None;
	let result = none_val.unwrap_or(99);
	assert_eq!(result, 99);
}

#[test]
fn test_chained_null_coalesce() {
	let a: Option<i32> = None;
	let b: Option<i32> = None;
	let c: Option<i32> = Some(100);
	let result = a.or(b).or(c).unwrap_or(0);
	assert_eq!(result, 100);
}

#[test]
fn test_chained_null_coalesce_all_none() {
	let a: Option<i32> = None;
	let b: Option<i32> = None;
	let result = a.or(b).unwrap_or(55);
	assert_eq!(result, 55);
}

#[test]
fn test_null_coalesce_double_try() {
	fn returns_result() -> Result<Result<i32, ()>, ()> {
		Ok(Ok(10))
	}

	fn test_double_try() -> Result<i32, ()> {
		let val = returns_result()??;
		Ok(val)
	}

	assert_eq!(test_double_try(), Ok(10));
}

#[test]
fn test_null_coalesce_combined() {
	fn get_option() -> Result<Option<i32>, ()> {
		Ok(None)
	}

	fn combined() -> Result<i32, ()> {
		let val = get_option()?.unwrap_or(999);
		Ok(val)
	}

	assert_eq!(combined(), Ok(999));
}

#[test]
fn test_null_coalesce_nested_optionals() {
	let nested: Option<Option<i32>> = Some(None);
	let inner = nested.flatten().unwrap_or(77);
	assert_eq!(inner, 77);

	let nested_some: Option<Option<i32>> = Some(Some(88));
	let inner_val = nested_some.flatten().unwrap_or(77);
	assert_eq!(inner_val, 88);
}

#[test]
fn test_null_coalesce_zero_default() {
	let none_val: Option<i32> = None;
	let zero_default = none_val.unwrap_or(0);
	assert_eq!(zero_default, 0);
}

#[test]
fn test_null_coalesce_negative_default() {
	let none_val: Option<i32> = None;
	let neg_default = none_val.unwrap_or(-1);
	assert_eq!(neg_default, -1);
}

#[test]
fn test_null_coalesce_complex_expression() {
	let none_val: Option<i32> = None;
	let computation = none_val.unwrap_or(10 + 20 * 2);
	assert_eq!(computation, 50);
}

#[test]
fn test_null_coalesce_string() {
	let opt_str: Option<String> = None;
	let str_result = opt_str.unwrap_or_else(|| "fallback".to_string());
	assert_eq!(str_result, "fallback");

	let some_str: Option<String> = Some("original".to_string());
	let str_result2 = some_str.unwrap_or_else(|| "fallback".to_string());
	assert_eq!(str_result2, "original");
}

#[test]
fn test_null_coalesce_multiple_none_chain() {
	let n1: Option<i32> = None;
	let n2: Option<i32> = None;
	let n3: Option<i32> = None;
	let result = n1.or(n2).or(n3).unwrap_or(111);
	assert_eq!(result, 111);
}

#[test]
fn test_null_coalesce_first_some_in_chain() {
	let first_some = Some(5).or(Some(10)).unwrap_or(20);
	assert_eq!(first_some, 5);
}

#[test]
fn test_null_coalesce_second_some_in_chain() {
	let second_some = (None::<i32>).or(Some(15)).unwrap_or(30);
	assert_eq!(second_some, 15);
}

#[test]
fn test_null_coalesce_bool() {
	let opt_bool: Option<bool> = None;
	let bool_result = opt_bool.unwrap_or(false);
	assert_eq!(bool_result, false);

	let some_bool: Option<bool> = Some(true);
	let bool_result2 = some_bool.unwrap_or(false);
	assert_eq!(bool_result2, true);
}

#[test]
fn test_null_coalesce_char() {
	let opt_char: Option<char> = None;
	let char_result = opt_char.unwrap_or('x');
	assert_eq!(char_result, 'x');
}
