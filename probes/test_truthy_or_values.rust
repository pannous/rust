#!/usr/bin/env rust

// Python-style truthy or: returns first truthy value or last value
// 34 or 3 == 34
// 0 or 5 == 5
// "" or "hello" == "hello"
//
// To implement:
// - Add `or` as infix operator (like `??` for Option)
// similar to 0 and 4 see test_truthy_and_complex.rust and test_truthy_and.rust
// - Desugar `a or b` to `if (&a).is_truthy() { a } else { b }`
// - Handle short-circuit evaluation
// - Support type coercion when needed
//

#[test]
fn test_integer_or_returns_value() {
    // First value is truthy, return it
    let result = 34 or 3;
    eq!(result, 34);

    // First value is falsy (0), return second
    let result2 = 0 or 5;
    eq!(result2, 5);

    // Both truthy, return first
    let result3 = 10 or 20;
    eq!(result3, 10);

    // Both falsy (0), return second
    let result4 = 0 or 0;
    eq!(result4, 0);
}

#[test]
fn test_negative_integers_or() {
    // Negative numbers are truthy
    let result = -1 or 5;
    eq!(result, -1);

    let result2 = 0 or -5;
    eq!(result2, -5);
}

#[test]
fn test_float_or_returns_value() {
    // First float is truthy, return it
    let result = 3.14 or 2.71;
    eq!(result, 3.14);

    // First float is falsy (0.0), return second
    let result2 = 0.0 or 2.71;
    eq!(result2, 2.71);

    // Both falsy
    let result3 = 0.0 or 0.0;
    eq!(result3, 0.0);
}

#[test]
fn test_string_or_returns_value() {
    // First string is truthy, return it
    let result = "hello" or "world";
    eq!(result, "hello");

    // First string is falsy (empty), return second
    let result2 = "" or "world";
    eq!(result2, "world");

    // Both empty
    let result3 = "" or "";
    eq!(result3, "");
}

#[test]
fn test_string_type_or_returns_value() {
    // First String is truthy, return it
    let result = String::from("hello") or String::from("world");
    eq!(result, "hello");

    // First String is falsy (empty), return second
    let result2 = String::new() or String::from("world");
    eq!(result2, "world");
}

#[test]
fn test_option_or_returns_value() {
    // First Some is truthy, return it
    let result = Some(42) or Some(99);
    eq!(result, Some(42));

    // First None is falsy, return second
    let result2 = None::<i32> or Some(99);
    eq!(result2, Some(99));

    // Both None
    let result3 = None::<i32> or None::<i32>;
    eq!(result3, None);

    // Some(0) is truthy (Some wraps the value)
    let result4 = Some(0) or Some(99);
    eq!(result4, Some(0));
}

#[test]
fn test_vec_or_returns_value() {
    // First Vec is truthy (non-empty), return it
    let result = vec![1, 2, 3] or vec![4, 5];
    eq!(result, vec![1, 2, 3]);

    // First Vec is falsy (empty), return second
    let result2 = Vec::<i32>::new() or vec![4, 5];
    eq!(result2, vec![4, 5]);

    // Both empty
    let result3 = Vec::<i32>::new() or Vec::<i32>::new();
    eq!(result3.is_empty(), true);
}

// Mixed types require dynamic typing - not supported in Rust's static type system
// #[test]
// fn test_mixed_types_or() {
//     // Integer and float
//     let result = 0 or 3.14;
//     eq!(result, 3.14);
//
//     let result2 = 42 or 3.14;
//     eq!(result2, 42);
// }

#[test]
fn test_chained_or_returns_first_truthy() {
    // Returns first truthy value
    let result = 0 or 0 or 5 or 10;
    eq!(result, 5);

    // Mixed types not supported - commenting out
    // let result2 = 0 or false or 0 or 42;
    // eq!(result2, 42);

    // All truthy, returns first
    let result3 = 10 or 20 or 30;
    eq!(result3, 10);
}

#[test]
fn test_or_in_assignment() {
    // Common pattern: default value
    let input = 0;
    let value = input or 100;
    eq!(value, 100);

    let input2 = 42;
    let value2 = input2 or 100;
    eq!(value2, 42);
}

#[test]
fn test_or_with_function_calls() {
    fn get_zero() -> i32 { 0 }
    fn get_five() -> i32 { 5 }

    // Should short-circuit: if first is truthy, don't evaluate second
    let result = 42 or get_five();
    eq!(result, 42);

    // First is falsy, evaluate second
    let result2 = get_zero() or get_five();
    eq!(result2, 5);
}

#[test]
fn test_or_with_variables() {
    let x = 0;
    let y = 10;
    let z = 20;

    let result = x or y;
    eq!(result, 10);

    let result2 = y or z;
    eq!(result2, 10);

    let result3 = x or y or z;
    eq!(result3, 10);
}

#[test]
fn test_bool_or_returns_value() {
    // Even with bools, should return the value not convert to bool
    let result = false or true;
    eq!(result, true);

    let result2 = true or false;
    eq!(result2, true);

    // Both false
    let result3 = false or false;
    eq!(result3, false);
}

