#!/usr/bin/env rust
//! Complete dynload test with forked rustc #[dynexport] library

use std::ffi::{c_char, c_int, c_void, CStr, CString};

type VecU8Handle = *mut ();
type VecI32Handle = *mut ();
type StringHandle = *mut ();
type HashMapSSHandle = *mut ();
type HashMapIIHandle = *mut ();

#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct OptionI32 {
    value: i32,
    is_some: bool,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct DynexportMeta {
    type_hash: u64,
    compiler_hash: u32,
    flags: u32,
}

const RTLD_NOW: c_int = 0x2;

extern "C" {
    fn dlopen(filename: *const c_char, flags: c_int) -> *mut c_void;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
    fn dlclose(handle: *mut c_void) -> c_int;
    fn dlerror() -> *mut c_char;
}

struct DynLib(*mut c_void);

impl DynLib {
    fn open(path: &str) -> Result<Self, String> {
        let path_cstr = CString::new(path).unwrap();
        let handle = unsafe { dlopen(path_cstr.as_ptr(), RTLD_NOW) };
        if handle.is_null() {
            let err = unsafe { dlerror() };
            let msg = if err.is_null() {
                "unknown error".to_string()
            } else {
                unsafe { CStr::from_ptr(err).to_string_lossy().to_string() }
            };
            return Err(msg);
        }
        Ok(Self(handle))
    }

    fn sym(&self, name: &str) -> *mut c_void {
        let name_cstr = CString::new(name).unwrap();
        unsafe { dlsym(self.0, name_cstr.as_ptr()) }
    }

    fn meta(&self, name: &str) -> Option<DynexportMeta> {
        let meta_name = format!("dynexport_meta_{}", name);
        let sym = self.sym(&meta_name);
        if sym.is_null() {
            None
        } else {
            Some(unsafe { *(sym as *const DynexportMeta) })
        }
    }
}

impl Drop for DynLib {
    fn drop(&mut self) {
        unsafe { dlclose(self.0); }
    }
}

macro_rules! load_fn {
    ($lib:expr, $name:literal -> $ty:ty) => {{
        let sym = $lib.sym($name);
        assert!(!sym.is_null(), "Symbol {} not found", $name);
        unsafe { std::mem::transmute::<_, $ty>(sym) }
    }};
}
