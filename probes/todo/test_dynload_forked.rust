#!/usr/bin/env rust
//! Test dynload with dynexport_prelude
//!
//! Compile and run with:
//! rustc --edition 2021 test_dynload_prelude.rs -o test_dynload_prelude && ./test_dynload_prelude

use std::ffi::{c_char, c_int, c_void, CStr, CString, OsStr};

// Type definitions matching the prelude
type VecU8Handle = *mut ();
type VecI32Handle = *mut ();
type StringHandle = *mut ();
type HashMapSSHandle = *mut ();

#[repr(C)]
struct OptionI32 {
    value: i32,
    is_some: bool,
}

// Declare dlopen/dlsym/dlclose directly
const RTLD_NOW: c_int = 0x2;

extern "C" {
    fn dlopen(filename: *const c_char, flags: c_int) -> *mut c_void;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
    fn dlclose(handle: *mut c_void) -> c_int;
    fn dlerror() -> *mut c_char;
}

mod dynload {
    use super::*;

    #[repr(C)]
    #[derive(Debug, Clone, Copy)]
    pub struct DynexportMeta {
        pub type_hash: u64,
        pub compiler_hash: u32,
        pub flags: u32,
    }

    pub struct DynLibrary {
        handle: *mut c_void,
    }

    impl DynLibrary {
        pub unsafe fn open<P: AsRef<OsStr>>(path: P) -> Result<Self, String> {
            let path = path.as_ref();
            let path_cstr = CString::new(path.to_str().unwrap()).unwrap();
            let handle = dlopen(path_cstr.as_ptr(), RTLD_NOW);
            if handle.is_null() {
                let err = dlerror();
                let msg = if err.is_null() {
                    "unknown error".to_string()
                } else {
                    CStr::from_ptr(err).to_string_lossy().to_string()
                };
                return Err(format!("dlopen failed: {}", msg));
            }
            Ok(Self { handle })
        }

        pub fn get_metadata(&self, symbol_name: &str) -> Option<DynexportMeta> {
            let meta_name = format!("dynexport_meta_{}\0", symbol_name);
            unsafe {
                let sym = dlsym(self.handle, meta_name.as_ptr() as *const c_char);
                if sym.is_null() {
                    None
                } else {
                    Some(*(sym as *const DynexportMeta))
                }
            }
        }

        pub unsafe fn get_symbol<T>(&self, name: &str) -> Option<T> {
            let name_cstr = CString::new(name).unwrap();
            let sym = dlsym(self.handle, name_cstr.as_ptr());
            if sym.is_null() {
                None
            } else {
                Some(std::mem::transmute_copy(&sym))
            }
        }
    }

    impl Drop for DynLibrary {
        fn drop(&mut self) {
            unsafe {
                dlclose(self.handle);
            }
        }
    }
}
