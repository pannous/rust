#!/usr/bin/env rust
//! Test: Load and use a #[dynexport] library
//!
//! First compile test_dynexport_lib.rs with forked rustc:
//!   rustc --edition 2021 --crate-type cdylib test_dynexport_lib.rs -o libdynexport_test.dylib
//!
//! Then compile and run this:
//!   rustc --edition 2021 test_dynexport_user.rs && ./test_dynexport_user

use std::ffi::{c_char, c_int, c_void, CStr, CString};

// Platform-specific library extension
#[cfg(target_os = "macos")]
const LIB_NAME: &str = "./libdynexport_test.dylib";
#[cfg(target_os = "linux")]
const LIB_NAME: &str = "./libdynexport_test.so";
#[cfg(target_os = "windows")]
const LIB_NAME: &str = "./dynexport_test.dll";

const RTLD_NOW: c_int = 0x2;

extern "C" {
    fn dlopen(filename: *const c_char, flags: c_int) -> *mut c_void;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
    fn dlclose(handle: *mut c_void) -> c_int;
    fn dlerror() -> *mut c_char;
}

/// Metadata structure generated by #[dynexport]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct DynexportMeta {
    type_hash: u64,
    compiler_hash: u32,
    flags: u32,
}

/// Helper to load a symbol
fn load_sym(handle: *mut c_void, name: &str) -> *mut c_void {
    let name_c = CString::new(name).unwrap();
    unsafe { dlsym(handle, name_c.as_ptr()) }
}

/// Helper to load metadata
fn load_meta(handle: *mut c_void, name: &str) -> Option<DynexportMeta> {
    let meta_name = format!("dynexport_meta_{}", name);
    let sym = load_sym(handle, &meta_name);
    if sym.is_null() {
        None
    } else {
        Some(unsafe { *(sym as *const DynexportMeta) })
    }
}
