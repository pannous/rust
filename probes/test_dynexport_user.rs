#!/usr/bin/env rustc
//! Test: Load and use a #[dynexport] library
//!
//! First compile test_dynexport_lib.rs with forked rustc:
//!   rustc --edition 2021 --crate-type cdylib test_dynexport_lib.rs -o libdynexport_test.dylib
//!
//! Then compile and run this:
//!   rustc --edition 2021 test_dynexport_user.rs && ./test_dynexport_user

use std::ffi::{c_char, c_int, c_void, CStr, CString};

// Platform-specific library extension
#[cfg(target_os = "macos")]
const LIB_NAME: &str = "./libdynexport_test.dylib";
#[cfg(target_os = "linux")]
const LIB_NAME: &str = "./libdynexport_test.so";
#[cfg(target_os = "windows")]
const LIB_NAME: &str = "./dynexport_test.dll";

const RTLD_NOW: c_int = 0x2;

extern "C" {
    fn dlopen(filename: *const c_char, flags: c_int) -> *mut c_void;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
    fn dlclose(handle: *mut c_void) -> c_int;
    fn dlerror() -> *mut c_char;
}

/// Metadata structure generated by #[dynexport]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct DynexportMeta {
    type_hash: u64,
    compiler_hash: u32,
    flags: u32,
}

/// Helper to load a symbol
fn load_sym(handle: *mut c_void, name: &str) -> *mut c_void {
    let name_c = CString::new(name).unwrap();
    unsafe { dlsym(handle, name_c.as_ptr()) }
}

/// Helper to load metadata
fn load_meta(handle: *mut c_void, name: &str) -> Option<DynexportMeta> {
    let meta_name = format!("dynexport_meta_{}", name);
    let sym = load_sym(handle, &meta_name);
    if sym.is_null() {
        None
    } else {
        Some(unsafe { *(sym as *const DynexportMeta) })
    }
}

fn main() {
    println!("=== Hello World Dynamic Library Demo ===\n");

    // Open the library
    let path = CString::new(LIB_NAME).unwrap();
    let handle = unsafe { dlopen(path.as_ptr(), RTLD_NOW) };

    if handle.is_null() {
        let err = unsafe { dlerror() };
        let msg = if err.is_null() {
            "unknown error"
        } else {
            unsafe { CStr::from_ptr(err).to_str().unwrap_or("unknown") }
        };
        eprintln!("Failed to load {}: {}", LIB_NAME, msg);
        eprintln!("\nMake sure to compile test_dynexport_lib.rs first:");
        eprintln!("  rustc --edition 2021 --crate-type cdylib test_dynexport_lib.rs -o libdynexport_test.dylib");
        std::process::exit(1);
    }

    println!("Loaded: {}\n", LIB_NAME);

    // --- assert!()metadata ---
    println!("--- Metadata ---");
    for name in &["add", "multiply", "greet", "factorial"] {
        if let Some(meta) = load_meta(handle, name) {
            println!("{}: type=0x{:016x} compiler=0x{:08x}",
                     name, meta.type_hash, meta.compiler_hash);
        }
    }

    // --- Use add ---
    println!("\n--- add(2, 3) ---");
    let add: extern "C" fn(i32, i32) -> i32 =
        unsafe { std::mem::transmute(load_sym(handle, "add")) };
    let result = add(2, 3);
    println!("Result: {}", result);
    eq!(result, 5);

    // --- Use multiply ---
    println!("\n--- multiply(3.14, 2.0) ---");
    let multiply: extern "C" fn(f64, f64) -> f64 =
        unsafe { std::mem::transmute(load_sym(handle, "multiply")) };
    let result = multiply(3.14, 2.0);
    println!("Result: {:.2}", result);
    assert!((result - 6.28).abs() < 0.001);

    // --- Use greet ---
    println!("\n--- greet(\"Dynamic Rust\") ---");
    let greet: extern "C" fn(*const c_char) -> *mut c_char =
        unsafe { std::mem::transmute(load_sym(handle, "greet")) };
    let free_string: extern "C" fn(*mut c_char) =
        unsafe { std::mem::transmute(load_sym(handle, "free_string")) };

    let name = CString::new("Dynamic Rust").unwrap();
    let greeting = greet(name.as_ptr());
    let greeting_str = unsafe { CStr::from_ptr(greeting).to_str().unwrap() };
    println!("Result: {}", greeting_str);
    eq!(greeting_str, "Hello, Dynamic Rust!");
    free_string(greeting);

    // --- Use factorial ---
    println!("\n--- factorial(10) ---");
    let factorial: extern "C" fn(u32) -> u64 =
        unsafe { std::mem::transmute(load_sym(handle, "factorial")) };
    let result = factorial(10);
    println!("Result: {}", result);
    eq!(result, 3628800);

    // --- Use sum_array ---
    println!("\n--- sum_array([1,2,3,4,5]) ---");
    let sum_array: extern "C" fn(*const i32, usize) -> i64 =
        unsafe { std::mem::transmute(load_sym(handle, "sum_array")) };
    let nums = [1i32, 2, 3, 4, 5];
    let result = sum_array(nums.as_ptr(), nums.len());
    println!("Result: {}", result);
    eq!(result, 15);

    // Cleanup
    unsafe { dlclose(handle); }

    println!("\n=== All tests passed! ===");
}
